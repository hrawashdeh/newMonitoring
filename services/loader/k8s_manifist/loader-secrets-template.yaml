apiVersion: v1
kind: Secret
metadata:
  name: loader-secrets
  namespace: loader-services
  labels:
    app: loader-service
    component: backend
type: Opaque
data:
  # ============================================================================
  # REQUIRED SECRETS (Must be set - no defaults)
  # ============================================================================

  # PostgreSQL Primary Database Connection (Target database where ETL writes data)
  # Used by: Spring JPA datasource configuration for loader and signals schemas
  # Format: jdbc:postgresql://HOST:PORT/DATABASE
  # Example: jdbc:postgresql://postgresql.loader-infra.svc.cluster.local:5432/alerts
  # Generate: echo -n "jdbc:postgresql://YOUR_HOST:5432/alerts" | base64
  SPRING_DATASOURCE_URL: ""

  # PostgreSQL database username for application connection
  # Used by: Spring JPA datasource authentication
  # Should have: CREATE, SELECT, INSERT, UPDATE, DELETE on loader and signals schemas
  # Example: alerts
  # Generate: echo -n "YOUR_USERNAME" | base64
  SPRING_DATASOURCE_USERNAME: ""

  # PostgreSQL database password for application user
  # Used by: Spring JPA datasource authentication
  # Security: Strong password required for production
  # Generate password: openssl rand -base64 20
  # Generate secret: echo -n "YOUR_PASSWORD" | base64
  SPRING_DATASOURCE_PASSWORD: ""

  # AES-256-GCM Encryption Key for sensitive database column encryption
  # Used by: EncryptionService to encrypt/decrypt SourceDatabase.passWord and Loader.loaderSql fields
  # Format: 32 bytes (256 bits) base64-encoded
  # Security: CRITICAL - Store securely, never commit to git, rotate periodically
  # Algorithm: AES-256-GCM with random IV per encryption, authenticated encryption
  # Note: Required for application startup (fails fast if missing or invalid)
  # Generate key: openssl rand -base64 32
  # Generate secret: echo -n "$(openssl rand -base64 32)" | base64
  # Example: e2mWpFHBa3+3DRfZtaNCADsy3E7FArTZ2RFGCRsxod4= (DO NOT USE IN PRODUCTION)
  ENCRYPTION_KEY: ""

  # ============================================================================
  # AUTHENTICATION & AUTHORIZATION SECRETS
  # ============================================================================

  # JWT Token Signing Secret for HMAC-SHA256 authentication
  # Used by: JwtTokenProvider to sign and verify JWT tokens for API authentication
  # Format: Minimum 256 bits (32 bytes) for HMAC-SHA256 security
  # Security: Strong secret required, rotate periodically, never expose in logs
  # Default (dev only): devSecretKeyForJwtTokenGenerationMustBeAtLeast256BitsLongForHmacSha256Algorithm
  # Generate secret: openssl rand -base64 64
  # Generate k8s secret: echo -n "$(openssl rand -base64 64)" | base64
  JWT_SECRET: ""

  # JWT Token Expiration Time in milliseconds
  # Used by: JwtTokenProvider to set token expiration
  # Format: Integer milliseconds (86400000 = 24 hours, 3600000 = 1 hour)
  # Default: 86400000 (24 hours)
  # Security: Shorter expiration is more secure but requires more frequent re-authentication
  # Generate: echo -n "86400000" | base64
  JWT_EXPIRATION_MS: "ODY0MDAwMDA="  # 24 hours (default)

  # ============================================================================
  # OPTIONAL CONFIGURATION SECRETS
  # ============================================================================

  # Spring Active Profile (dev, prod, test)
  # Used by: Spring Boot to determine which application-{profile}.yaml to load
  # Values: dev (local development), prod (production), test (automated testing)
  # Default: dev (from application.yaml)
  # Generate: echo -n "prod" | base64
  SPRING_PROFILES_ACTIVE: "cHJvZA=="  # "prod"

  # Loader Replica/Pod Name for distributed execution tracking
  # Used by: DefaultReplicaNameProvider to identify which pod executed a loader job
  # Format: String identifier (typically Kubernetes pod name)
  # Default: Uses HOSTNAME environment variable (automatically set to pod name in K8s)
  # Note: Usually NOT needed - K8s sets HOSTNAME automatically
  # Generate: echo -n "loader-service-abc123" | base64
  # LOADER_REPLICA_NAME: ""

  # ============================================================================
  # MYSQL SOURCE DATABASE CONNECTION POOL SETTINGS (Optional tuning)
  # ============================================================================
  # Note: These settings apply to SOURCE databases (where ETL reads from),
  #       NOT the primary PostgreSQL database (where ETL writes to)
  # Used by: SourceRegistry and HikariCP for dynamic source database connections
  # Defaults are optimized for production; override only if needed

  # Minimum number of idle connections in pool per source database
  # Default: 2
  # Tuning: Lower value saves resources, higher reduces connection latency
  # Generate: echo -n "2" | base64
  # SOURCES_MYSQL_POOL_MINIMUM_IDLE: "Mg=="

  # Maximum total connections in pool per source database
  # Default: 10
  # Tuning: Higher value allows more concurrent queries, consumes more resources
  # Warning: Don't exceed source database max_connections limit
  # Generate: echo -n "10" | base64
  # SOURCES_MYSQL_POOL_MAXIMUM_POOL_SIZE: "MTA="

  # Idle connection timeout in milliseconds
  # Default: 600000 (10 minutes)
  # Tuning: Shorter timeout releases idle connections faster
  # Generate: echo -n "600000" | base64
  # SOURCES_MYSQL_POOL_IDLE_TIMEOUT: "NjAwMDAw"

  # Connection acquisition timeout in milliseconds
  # Default: 30000 (30 seconds)
  # Tuning: Shorter timeout fails faster, longer allows retry during high load
  # Generate: echo -n "30000" | base64
  # SOURCES_MYSQL_POOL_CONNECTION_TIMEOUT: "MzAwMDA="

  # Connection leak detection threshold in milliseconds
  # Default: 0 (disabled)
  # Tuning: Set to >0 (e.g., 60000 = 1 min) to detect connection leaks in logs
  # Warning: Only enable for debugging - adds performance overhead
  # Generate: echo -n "0" | base64
  # SOURCES_MYSQL_POOL_LEAK_DETECTION: "MA=="

---
# ============================================================================
# SECRET GENERATION HELPER COMMANDS
# ============================================================================
# Use these commands to generate secure values for production:
#
# 1. Generate Encryption Key (256-bit):
#    ENCRYPTION_KEY=$(openssl rand -base64 32)
#    echo -n "$ENCRYPTION_KEY" | base64
#
# 2. Generate JWT Secret (512-bit):
#    JWT_SECRET=$(openssl rand -base64 64)
#    echo -n "$JWT_SECRET" | base64
#
# 3. Generate Strong Database Password:
#    DB_PASSWORD=$(openssl rand -base64 20)
#    echo -n "$DB_PASSWORD" | base64
#
# 4. Encode any plaintext value to base64:
#    echo -n "your-plaintext-value" | base64
#
# 5. Decode base64 value (for verification):
#    echo "base64-encoded-value" | base64 -d
#
# ============================================================================
# DEPLOYMENT WORKFLOW
# ============================================================================
# 1. Copy this template: cp loader-secrets-template.yaml loader-secrets.yaml
# 2. Fill in all required secrets (SPRING_DATASOURCE_*, ENCRYPTION_KEY, JWT_SECRET)
# 3. Optional: Fill in optional tuning parameters
# 4. Apply secret: kubectl apply -f loader-secrets.yaml
# 5. Deploy application: kubectl apply -f loader-deployment.yaml
# 6. IMPORTANT: Add loader-secrets.yaml to .gitignore (never commit secrets!)
#
# For Sealed Secrets (recommended for GitOps):
# 1. Install kubeseal: brew install kubeseal
# 2. Create sealed secret:
#    kubeseal --format=yaml \
#      --controller-name=sealed-secrets \
#      --controller-namespace=kube-system \
#      < loader-secrets.yaml > loader-sealed-secrets.yaml
# 3. Commit sealed secret to git (safe - encrypted with cluster key)
# 4. Apply: kubectl apply -f loader-sealed-secrets.yaml
# ============================================================================
